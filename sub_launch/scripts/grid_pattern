#!/usr/bin/env python

import argparse
import math
import numpy

import roslib; roslib.load_manifest('sub_launch')
import rospy
import actionlib
from actionlib_msgs.msg import GoalStatus
from std_msgs.msg import Header
from geometry_msgs.msg import Pose, Quaternion, Point
from nav_msgs.msg import Odometry
from tf import transformations

from c3_trajectory_generator.msg import MoveToAction, MoveToGoal

parser = argparse.ArgumentParser()
parser.add_argument('--square', action='store_true')
args = parser.parse_args()

rospy.init_node('grid_pattern')
client = actionlib.SimpleActionClient('moveto', MoveToAction)
print 'Waiting for server...'
client.wait_for_server()

EAST, NORTH, WEST, SOUTH = [transformations.quaternion_about_axis(math.pi/2*i, [0, 0, 1]) for i in xrange(4)]

xyz_array = lambda o: numpy.array([o.x, o.y, o.z])

def go(position, orientation):
    res = client.send_goal_and_wait(MoveToGoal(
        header=Header(
            frame_id='/map',
        ),
        pose=Pose(
            position=Point(*position),
            orientation=Quaternion(*orientation),
        ),
    ))
    if res != GoalStatus.SUCCEEDED:
        raise ValueError('result = %i' % res)

def get_current():
    res = [None]
    def cb(msg):
        res[0] = msg
    sub = rospy.Subscriber('/odom', Odometry, cb)
    while res[0] is None:
        rospy.sleep(.01)
    sub.unregister()
    return res[0]
current = get_current()


def go_rel_enu(relpos, facing):
    global pos
    print 'Turning...'
    go(pos, facing)
    print '...done, going...'
    pos += relpos
    go(pos, facing)
    print '...done.'
pos = xyz_array(current.pose.pose.position)

pos[2] = -.5

print 'Sending goal...'

while True:
    if args.square:
        go_rel_enu([5, 0, 0], EAST)
        go_rel_enu([0, 5, 0], NORTH)
        go_rel_enu([-5, 0, 0], WEST)
        go_rel_enu([0, -5, 0], SOUTH)
    else:
        go_rel_enu([5, 0, 0], EAST)
        go_rel_enu([0, 1, 0], NORTH)
        go_rel_enu([-5, 0, 0], WEST)
        go_rel_enu([0, 1, 0], NORTH)
