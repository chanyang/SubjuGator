#!/usr/bin/env python

import os
import signal
import sys
import time

import roslib; roslib.load_manifest('sub_launch')
import rospy
import actionlib

from uf_common import orientation_helpers
from uf_common.msg import MoveToAction

if len(sys.argv) < 2:
    print 'Examples:'
    print 'send_waypoint depth 2'
    print 'send_waypoint forward 5'
    print 'send_waypoint set_orientation NORTH'
    print 'send_waypoint yaw_left_deg 30'
    sys.exit()

rospy.init_node('send_waypoint')

print 'Waiting for server...'
client = actionlib.SimpleActionClient('moveto', MoveToAction)
client.wait_for_server()
go = client.send_goal_and_wait

print 'Waiting for current position...'
p = orientation_helpers.PoseEditor.from_Odometry_topic()

args = [eval(x, orientation_helpers.__dict__) for x in sys.argv[2:]] # lets you do "set_orientation NORTH"
if len(args) >= 2:
    args = [args]
p = getattr(p, sys.argv[1])(*args)

print 'Sending goal...'
def done(goal_status, result):
    print 'Reached goal, killing self.'
    os.kill(os.getpid(), signal.SIGKILL) # gah, i hate threads. this is the only way i could get this to terminate
client.send_goal(p, done_cb=done)

print 'Press Enter to cancel...'
raw_input()

print 'Cancelling...'
client.cancel_goal()
print 'Cancelled, exiting.'
